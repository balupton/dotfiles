#!/usr/bin/env bash

function boundation_all() (
	source "$DOROTHY/sources/bash.bash"

	# if the secrets aren't provided, fetch them and reload
	if test -z "${GITHUB_ACCESS_TOKEN-}"; then
		bevry-auth -- "$0" "$@"
		return
	fi

	# =====================================
	# Arguments

	function help {
		cat <<-EOF >/dev/stderr
			ABOUT:
			Upgrade all of a GitHub user's Node.js packages.

			USAGE:
			boundation-all [...options].

			OPTIONS:
			--user=<user>
			--filter=<filter>
			--start=<repo>
			--skip=<repo>
			--only=<repo>
			--start-after=<repo>
			    Same as --start=<repo> --skip=<repo>
		EOF
		if test "$#" -ne 0; then
			echo-error "$@"
		fi
		return 22 # EINVAL 22 Invalid argument
	}

	# process
	# --user=docpad --filter='-plugin-'
	local item option_user='bevry' option_filter='' option_start='' option_deps='' option_slugs=() option_args=() option_skips=()
	while test "$#" -ne 0; do
		item="$1"
		shift
		case "$item" in
		'--help' | '-h') help ;;
		'--user='*) option_user="${item#*=}" ;;
		'--filter='*) option_filter="${item#*=}" ;;
		'--start='*) option_start="${item#*=}" ;;
		'--zero-deps'*)
			option_deps="$(get-flag-value --non-affirmative -- "$item")"
			;;
		'--has-deps'*)
			option_deps="$(get-flag-value --affirmative -- "$item")"
			;;
		'--skip='*) option_skips+=("${item#*=}") ;;
		'--slug='*) option_slugs+=("${item#*=}") ;;
		'--start-after='*)
			option_start="${item#*=}"
			option_skips+=("$option_start")
			;;
		'--')
			option_args+=("$@")
			shift $#
			break
			;;
		'--'*) help "An unrecognised flag was provided: $item" ;;
		*) help "An unrecognised argument was provided: $item" ;;
		esac
	done

	# prepare option_skips
	# if fetch "https://bevry.me/api/github/orgs" | jq -r '.[]' | grep --quiet --fixed-strings --regexp="$user"; then
	if test "$USER" = 'balupton'; then
		option_skips+=(
			.github
			base
			billing
			boundation # manual
			coda-packs
			designs
			discourse-component-youtubetimestamps
			discourser # @todo
			dorothy
			duration-timestamp # @todo
			fountain
			github-api # rate limits
			legal
			links
			meetings
			ropo                      # @todo
			staticsitegenerators-list # @todo
			staticsitegenerators-website
			study
			terraform-scaleway-hashistack
			watchr # @todo
			workers
		)
	else
		option_skips+=(
			.github
		)
	fi

	# if no slugs, fetch all for the user
	if test "${#option_slugs[@]}" -eq 0; then
		mapfile -t option_slugs < <(fetch "https://bevry.me/api/github/repos/${option_user}" | jq -r '.[]' | sort)
	fi

	# =====================================
	# Action

	# check we aren't in a package
	if test -f package.json; then
		echo-error 'You just tried to run boundation-all in a package, you forgot to cd out of debugging a package failure.'
		return 22 # EINVAL 22 Invalid argument
	fi

	# npm workaround
	# https://omrilotan.medium.com/npx-breaking-on-ci-b9f3f61d4676
	export npm_config_yes=true

	# note progress
	local failed_repos=() success_repos=()
	function on_finish {
		if test "${#success_repos[@]}" -ne 0; then
			echo-style --success='boundation success on:'
			__print_lines "${success_repos[@]}"
		fi
		if test "${#failed_repos[@]}" -ne 0; then
			echo-style --error='boundation failed on:'
			__print_lines "${failed_repos[@]}"
		fi
	}
	trap on_finish EXIT SIGINT SIGTERM

	# loop
	local pwd="$PWD" ready='no' repo slug index repo_deps package
	local -i count="${#option_slugs[@]}"
	if test -z "$option_start"; then
		ready='yes'
	fi
	for index in "${!option_slugs[@]}"; do
		# scan
		slug="${option_slugs[index]}"
		repo="${slug#*/}"
		if test "$ready" = 'no' -a "$repo" = "$option_start"; then
			echo-style --magenta="found $repo, starting"
			ready='yes'
		fi

		# checks
		if test "$ready" = 'no'; then
			echo-style --dim="skipping $repo (not yet ready)"
			continue
		elif is-needle --needle="$slug" -- "${option_skips[@]}"; then
			echo-style --dim="skipping $slug (slug was in skips)"
			continue
		elif is-needle --needle="$repo" -- "${option_skips[@]}"; then
			echo-style --dim="skipping $repo (repo was in skips)"
			continue
		elif test -n "$option_filter" && [[ $repo != *"$option_filter"* ]]; then
			echo-style --dim="skipping $repo (repo didn't match filter: $option_filter)"
			continue
		fi

		# check package
		package="$(fetch "https://raw.githubusercontent.com/${slug}/HEAD/package.json" 2>/dev/null)"
		if test -z "$package"; then
			echo-style --dim="skipping $repo (no package.json)"
			continue
		fi

		# check package deps
		repo_deps='no'
		if jq -r '.dependencies' <<<"$package" | grep --quiet --fixed-strings --regexp='{'; then
			repo_deps='yes'
		fi
		if test "$option_deps" = 'yes' -a "$repo_deps" = 'no'; then
			echo-style --dim="skipping $repo (it did not have deps)"
			continue
		elif test "$option_deps" = 'no' -a "$repo_deps" = 'yes'; then
			echo-style --dim="skipping $repo (it had deps)"
			continue
		fi

		# upgrade
		# use ( as { would cause return to exit our function, use [|| return] as the block conditional, i.e. [) ||] and [} ||] causes errexit to disable
		(
			# log
			failed_repos+=("$repo")
			echo-title -- "$repo [$index/$count]" || return
			echo-style --h1="$repo" || return
			# clone the repo fresh and set the correct origin in case of fork
			# don't use subshell as that breaks strict mode
			# don't use gh, as it clones forks then sets the origin to not the fork
			cd "$pwd" || return
			fs-rm --quiet --no-confirm -- "$repo" || return
			git clone "git@github.com:$slug.git" || return
			cd "$repo" || return
			gh repo set-default "$slug" >/dev/null || return
			# run the upgrade
			boundation-upgrade "${option_args[@]}" || return
			# get out of the directory, so it can be removed
			cd "$pwd" || return
			# remove the directory
			fs-rm --quiet --no-confirm -- "$repo" || return
			# wait for the publish to propagate
			waiter 60 || return
			# note it succeeded
			echo-style --g1="$repo" || return
			# remove from failed repos
			failed_repos=("${failed_repos[@]/$repo/}")
			success_repos+=("$repo")
		) || (
			# check status
			local status="$?"
			# note failure
			echo-style --e1="$repo" ' ' --code="$status" || return
			# keep repo (if it exists), but ensure we are correct location
			cd "$pwd" || return
			# if aborted, propagate
			if is-abort -- "$status"; then
				return "$status"
			fi
		)
	done

	# reset repo for on_finish
	repo=''
)

# fire if invoked standalone
if test "$0" = "${BASH_SOURCE[0]}"; then
	boundation_all "$@"
fi
