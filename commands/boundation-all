#!/usr/bin/env bash

function boundation_all() (
	source "$DOROTHY/sources/bash.bash"

	# if the secrets aren't provided, fetch them and reload
	if [[ -z ${GITHUB_ACCESS_TOKEN-} ]]; then
		bevry-auth -- "$0" "$@"
		return
	fi

	# =====================================
	# Arguments

	function help {
		cat <<-EOF >&2
			ABOUT:
			Upgrade all of a GitHub user's Node.js packages.

			USAGE:
			boundation-all [...options].

			OPTIONS:
			--user=<user>
			--filter=<filter>
			--start=<repo>
			--skip=<repo>
			--only=<repo>
			--start-after=<repo>
			    Same as --start=<repo> --skip=<repo>
		EOF
		if [[ $# -ne 0 ]]; then
			__print_error "$@"
		fi
		return 22 # EINVAL 22 Invalid argument
	}

	# process
	# --user=docpad --filter='-plugin-'
	local item option_user='bevry' option_filter='' option_start='' option_deps='' option_slugs=() option_args=() option_skips=()
	while [[ $# -ne 0 ]]; do
		item="$1"
		shift
		case "$item" in
		'--help' | '-h') help ;;
		'--user='*) option_user="${item#*=}" ;;
		'--filter='*) option_filter="${item#*=}" ;;
		'--start='*) option_start="${item#*=}" ;;
		'--zero-deps'*) __flag --source={item} --target={option_deps} --non-affirmative ;;
		'--has-deps'*) __flag --source={item} --target={option_deps} --affirmative ;;
		'--skip='*) option_skips+=("${item#*=}") ;;
		'--slug='*) option_slugs+=("${item#*=}") ;;
		'--start-after='*)
			option_start="${item#*=}"
			option_skips+=("$option_start")
			;;
		'--')
			option_args+=("$@")
			shift $#
			break
			;;
		--*) __unrecognised_flag "$item" || return ;;
		*) __unrecognised_argument "$item" || return ;;
		esac
	done

	# prepare option_skips
	# if fetch "https://bevry.me/api/github/orgs" | jq -r '.[]' | grep --quiet --fixed-strings --regexp="$user"; then
	if [[ $option_user == 'bevry' ]]; then
		option_skips+=(
			.github
			base
			billing
			boundation # manual
			coda-packs
			designs
			discourse-component-youtubetimestamps
			discourser # @todo
			dorothy
			duration-timestamp # @todo
			fountain
			github-api # rate limits
			legal
			links
			meetings
			ropo                      # @todo
			staticsitegenerators-list # @todo
			staticsitegenerators-website
			study
			terraform-scaleway-hashistack
			watchr # @todo
			workers
		)
	else
		option_skips+=(
			.github
		)
	fi

	# if no slugs, fetch all for the user
	function __get_slugs {
		fetch "https://bevry.me/api/github/repos/${option_user}" | jq -r '.[]' | sort || return
	}
	if [[ ${#option_slugs[@]} -eq 0 ]]; then
		__split --target={option_slugs} --no-zero-length --invoke -- \
			__get_slugs
	fi

	# =====================================
	# Action

	# check we aren't in a package
	if [[ -f package.json ]]; then
		__print_error 'You just tried to run boundation-all in a package, you forgot to cd out of debugging a package failure.'
		return 22 # EINVAL 22 Invalid argument
	fi

	# npm workaround
	# https://omrilotan.medium.com/npx-breaking-on-ci-b9f3f61d4676
	export npm_config_yes=true

	# note progress
	local failed_repos=() success_repos=()
	function on_finish {
		if [[ ${#success_repos[@]} -ne 0 ]]; then
			__print_style --success='boundation success on:'
			__print_lines "${success_repos[@]}"
		fi
		if [[ ${#failed_repos[@]} -ne 0 ]]; then
			__print_style --error='boundation failed on:'
			__print_lines "${failed_repos[@]}"
		fi
	}
	trap on_finish EXIT SIGINT SIGTERM

	# loop
	local pwd="$PWD" ready='no' repo slug index repo_deps package
	local -i count="${#option_slugs[@]}"
	if [[ -z $option_start ]]; then
		ready='yes'
	fi
	for index in "${!option_slugs[@]}"; do
		# scan
		slug="${option_slugs[index]}"
		repo="${slug#*/}"
		if [[ $ready == 'no' && $repo == "$option_start" ]]; then
			__print_style --magenta="found $repo, starting"
			ready='yes'
		fi

		# checks
		if [[ $ready == 'no' ]]; then
			__print_style --dim="skipping $repo (not yet ready)"
			continue
		elif __has --source={option_skips} -- "$slug"; then
			__print_style --dim="skipping $slug (slug was in skips)"
			continue
		elif __has --source={option_skips} -- "$repo"; then
			__print_style --dim="skipping $repo (repo was in skips)"
			continue
		elif [[ -n $option_filter && $repo != *"$option_filter"* ]]; then
			__print_style --dim="skipping $repo (repo didn't match filter: $option_filter)"
			continue
		fi

		# check package
		package="$(fetch "https://raw.githubusercontent.com/${slug}/HEAD/package.json" 2>/dev/null)"
		if [[ -z $package ]]; then
			__print_style --dim="skipping $repo (no package.json)"
			continue
		fi

		# check package deps
		repo_deps='no'
		if jq -r '.dependencies' <<<"$package" | grep --quiet --fixed-strings --regexp='{'; then
			repo_deps='yes'
		fi
		if [[ $option_deps == 'yes' && $repo_deps == 'no' ]]; then
			__print_style --dim="skipping $repo (it did not have deps)"
			continue
		elif [[ $option_deps == 'no' && $repo_deps == 'yes' ]]; then
			__print_style --dim="skipping $repo (it had deps)"
			continue
		fi

		# upgrade
		# use ( as { would cause return to exit our function, use [|| return] as the block conditional, i.e. [) ||] and [} ||] causes errexit to disable
		(
			# log
			failed_repos+=("$repo")
			__print_style --terminal-title="$repo [$index/$count]" || return
			__print_style --h1="$repo" || return
			# clone the repo fresh and set the correct origin in case of fork
			# don't use subshell as that breaks strict mode
			# don't use gh, as it clones forks then sets the origin to not the fork
			cd "$pwd" || return
			fs-rm --quiet --no-confirm -- "$repo" || return
			git clone "git@github.com:$slug.git" || return
			cd "$repo" || return
			gh repo set-default "$slug" >/dev/null || return
			# run the upgrade
			boundation-upgrade "${option_args[@]}" || return
			# get out of the directory, so it can be removed
			cd "$pwd" || return
			# remove the directory
			fs-rm --quiet --no-confirm -- "$repo" || return
			# wait for the publish to propagate
			waiter 60 || return
			# note it succeeded
			__print_style --g1="$repo" || return
			# remove from failed repos
			__evict --source+target={failed_repos} --first -- "$repo" || return
			success_repos+=("$repo")
		) || (
			# check status
			local status="$?"
			# note failure
			__print_style --e1="$repo" ' ' --code="$status" || return
			# keep repo (if it exists), but ensure we are correct location
			cd "$pwd" || return
			# if aborted, propagate
			if is-abort -- "$status"; then
				return "$status"
			fi
		)
	done

	# reset repo for on_finish
	repo=''
)

# fire if invoked standalone
if [[ $0 == "${BASH_SOURCE[0]}" ]]; then
	boundation_all "$@"
fi
