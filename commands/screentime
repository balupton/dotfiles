#!/usr/bin/env nu

# Apple uses a different "starting point" for counting time than Unix systems.
# Unix counts seconds since January 1, 1970 00:00:00 UTC (called "Unix epoch")
# Apple's Core Data counts seconds since January 1, 2001 00:00:00 UTC (called "Core Data epoch")
# The difference between these two dates is exactly 978,307,200 seconds (31 years)
# We add this number to convert Apple's timestamps to standard Unix timestamps
const CORE_DATA_EPOCH_OFFSET = 978307200

# Full path to macOS Screen Time database
# $env.HOME = your user home directory (e.g., /Users/balupton)
# This SQLite database stores all Screen Time usage data
let KNOWLEDGE_DB_PATH = $"($env.HOME)/Library/Application Support/Knowledge/knowledgeC.db"

# Common app aliases for convenience
let APP_ALIASES = {
	"vscode": "com.microsoft.VSCode",
	"code": "com.microsoft.VSCode",
	"safari": "com.apple.Safari",
	"chrome": "com.google.Chrome",
	"firefox": "org.mozilla.firefox",
	"brave": "com.brave.Browser",
	"edge": "com.microsoft.edgemac",
	"slack": "com.tinyspeck.slackmacgap",
	"discord": "com.hnc.Discord",
	"spotify": "com.spotify.client",
	"telegram": "ru.keepcoder.Telegram",
	"whatsapp": "net.whatsapp.WhatsApp",
	"signal": "org.whispersystems.Signal-Desktop",
	"1password": "com.1password.1password",
	"obs": "com.obsproject.obs-studio",
	"xcode": "com.apple.dt.Xcode",
	"sketch": "com.bohemiancoding.sketch3",
	"figma": "com.figma.Desktop",
	"notion": "notion.id",
	"zoom": "us.zoom.xos",
	"teams": "com.microsoft.teams2",
	"plex": "tv.plex.desktop",
	"alfred": "com.runningwithcrayons.Alfred",
	"backblaze": "com.backblaze.BackblazeRestore",
	"kindle": "com.amazon.Kindle",
	"music": "com.apple.Music",
	"numbers": "com.apple.iWork.Numbers",
	"pages": "com.apple.iWork.Pages",
	"keynote": "com.apple.iWork.Keynote",
	"gitfox": "com.bytieful.Gitfox-setapp",
	"ghostty": "com.mitchellh.ghostty",
	"term": "com.apple.Terminal",
	"terminal": "com.apple.Terminal"
}

# Function to get bundle ID from an app path
def get_bundle_id [app_path: string] {
	try {
		let info_plist = $"($app_path)/Contents/Info.plist"
		if ($info_plist | path exists) {
			let bundle_id = (defaults read $info_plist CFBundleIdentifier | str trim)
			$bundle_id
		} else {
			null
		}
	} catch {
		null
	}
}

# Function to find apps and their bundle IDs with case-insensitive fuzzy matching
# This is somewhat similar to Dorothy's `get-app` command
def find_apps [query: string] {
	# Common app directories
	let app_dirs = [
		$"($env.HOME)/Applications",
		'/Applications'
		'/Applications/Setapp'
		'/Applications/Utilities'
		'/System/Applications'           # TextEdit
		'/System/Applications/Utilities' # Terminal
	]

	let all_apps = ($app_dirs | each { |dir|
		if ($dir | path exists) {
			try {
				let pattern = $"($dir)/*.app"
				let apps = (glob $pattern | where ($it | path type) == dir)
				$apps
			} catch { |err|
				print --stderr $"Error in ($dir): ($err.msg)"
				[]
			}
		} else {
			[]
		}
	} | flatten)

	# Extract app names and create fuzzy matches (case-insensitive)
	let query_lower = ($query | str downcase)
	let matches = ($all_apps | each { |app_path|
		let app_name = ($app_path | path basename | str replace ".app" "")
		let app_name_lower = ($app_name | str downcase)
		let bundle_id = (get_bundle_id $app_path)

		if $bundle_id != null {
			{
				name: $app_name,
				path: $app_path,
				bundle_id: $bundle_id,
				# Case-insensitive fuzzy matching - check if query is contained in app name
				score: (if ($app_name_lower | str contains $query_lower) { 1 } else { 0 })
			}
		}
	} | where bundle_id != null and score > 0 | sort-by score --reverse)

	$matches
}

# Function to resolve app input to bundle ID
# Tries: bundle ID → alias → app search → fallback to original input
def resolve_app [input: string] {
	# Check if it's already a bundle ID by counting dot-separated parts
	# Bundle IDs are reverse domain notation with 3 or more parts separated by dots
	# Examples: com.microsoft.VSCode (3 parts), com.apple.dt.Xcode (4 parts), tv.plex.desktop (3 parts)
	# This covers all valid bundle IDs regardless of TLD or domain structure
	let dot_parts = ($input | split row ".")
	if ($dot_parts | length) >= 3 {
		return $input
	}

	# Check aliases (case-insensitive)
	let input_lower = ($input | str downcase)
	let alias_result = ($APP_ALIASES | get -o $input_lower)
	if $alias_result != null {
		return $alias_result
	}

	# Search for apps (case-insensitive fuzzy matching
	let found_apps = (find_apps $input)
	if ($found_apps | length) > 0 {
		return $found_apps.0.bundle_id
	}

	# If nothing found, return original input (might be a bundle ID we don't recognize)
	$input
}

# Function to get screen time for a single app
def get_app_screentime [app_bundle_id: string, tz_offset_hours: int] {
	# Query the Screen Time database
	let result = (
		open $KNOWLEDGE_DB_PATH
		| query db $"
		SELECT
			SUM\(ZENDDATE - ZSTARTDATE\) AS total_seconds,
			CAST\(SUM\(ZENDDATE - ZSTARTDATE\) AS REAL\) / 60.0 AS total_minutes
		FROM ZOBJECT
		WHERE
			ZVALUESTRING = '($app_bundle_id)'
			AND ZSTREAMNAME = '/app/usage'
			AND date\(datetime\(ZSTARTDATE + ($CORE_DATA_EPOCH_OFFSET), 'unixepoch', '($tz_offset_hours) hours'\)\) = date\('now', '($tz_offset_hours) hours'\)
		"
	)

	# Check if we found any usage data
	if ($result | length) > 0 and ($result.0.total_seconds != null) {
		# We found data - calculate all the time units
		let total_seconds = ($result.0.total_seconds | into int)
		let total_minutes = ($result.0.total_minutes)
		let hours = ($total_seconds / 3600 | math floor)
		let remaining_minutes = (($total_seconds mod 3600) / 60 | math floor)
		let remaining_seconds = ($total_seconds mod 60)

		# Create human-readable format (e.g., "2h 34m 15s")
		let total_human = if $hours > 0 {
			$"($hours)h ($remaining_minutes)m ($remaining_seconds)s"
		} else if $remaining_minutes > 0 {
			$"($remaining_minutes)m ($remaining_seconds)s"
		} else {
			$"($remaining_seconds)s"
		}

		{
			app: $app_bundle_id,
			total_human: $total_human,
			total_seconds: $total_seconds,
			hours: $hours,
			minutes: $remaining_minutes,
			seconds: $remaining_seconds,
		}
	} else {
		# No data found - return empty data with same structure
		{
			app: $app_bundle_id,
			total_human: "0s",
			total_seconds: 0,
			hours: 0,
			minutes: 0,
			seconds: 0,
		}
	}
}

# Function to create a total row with summed values
def create_total_row [results: list] {
	let total_seconds_sum = ($results | get total_seconds | math sum)
	let total_hours = ($total_seconds_sum / 3600 | math floor)
	let remaining_minutes = (($total_seconds_sum mod 3600) / 60 | math floor)
	let remaining_seconds = ($total_seconds_sum mod 60)

	# Create human-readable format for total
	let total_human = if $total_hours > 0 {
		$"($total_hours)h ($remaining_minutes)m ($remaining_seconds)s"
	} else if $remaining_minutes > 0 {
		$"($remaining_minutes)m ($remaining_seconds)s"
	} else {
		$"($remaining_seconds)s"
	}

	{
		app: "",
		total_human: $total_human,
		total_seconds: $total_seconds_sum,
		hours: $total_hours,
		minutes: $remaining_minutes,
		seconds: $remaining_seconds,
	}
}

# Main function that gets called when you run the script
def main [
	# Application name(s), alias(es), or bundle ID(s) - can be multiple space-separated
	# Examples: "vscode", "chrome safari", "Visual Studio", "com.microsoft.VSCode"
	...apps: string
	# Command line flag to show help information (use --help or -h)
	--help(-h)
	# Output format: table (default), json, or seconds
	--format: string = "table"
	# Alias for --format=seconds (use --seconds or -s)
	--seconds(-s)
	# Alias for --format=json (use --json or -j)
	--json(-j)
] {
	# If user asks for help, show usage examples and exit
	if $help {
		print "Usage: screentime [app_name_or_bundle_id...] [--format=FORMAT] [--seconds] [--json]"
		print ""
		print "Flags:"
		print "  --format=FORMAT  Output format: table (default), json, or seconds"
		print "  --seconds, -s    Alias for --format=seconds (sum total seconds for multiple apps)"
		print "  --json, -j       Alias for --format=json (JSON output for nushell processing)"
		print "  --help, -h       Show this help message"
		print ""
		print "The script automatically tries to resolve app names in this order:"
		print "1. Check if it's already a bundle ID (3+ dot-separated parts)"
		print "2. Check built-in aliases (e.g., vscode → com.microsoft.VSCode)"
		print "3. Search installed apps with fuzzy matching (case-insensitive)"
		print ""
		print "Examples:"
		print "  screentime                              # VSCode (default table format)"
		print "  screentime vscode                       # VSCode (alias, table format)"
		print "  screentime vscode --seconds             # VSCode seconds only: 3947"
		print "  screentime vscode --format=seconds      # Same as --seconds"
		print "  screentime safari chrome --seconds      # Sum of Safari + Chrome seconds"
		print "  screentime vscode --json                # JSON output"
		print "  screentime vscode --format=json         # Same as --json"
		print ""
		print "Nushell usage examples:"
		print "  screentime vscode --json | from json | get total_seconds"
		print "  screentime safari chrome --json | from json | where total_seconds > 1000"
		print ""
		print "Multiple apps:"
		print "  screentime safari chrome                # Multiple apps (table format)"
		print "  screentime 'Visual Studio' Discord      # Fuzzy search + alias"
		print "  screentime com.microsoft.VSCode         # Direct bundle ID"
		print "  screentime CHROME SAFARI                # Case-insensitive"
		print ""
		print "Built-in aliases:"
		$APP_ALIASES | transpose key value | each { |row|
			print $"  ($row.key) → ($row.value)"
		}
		# Exit the function early
		return
	}

	# Count how many format options were specified
	let format_options_count = (
		($seconds | if $in { 1 } else { 0 }) +
		($json | if $in { 1 } else { 0 }) +
		(if $format != "table" { 1 } else { 0 })
	)

	# Error if multiple format options specified
	if $format_options_count > 1 {
		print "Error: Only one output format can be specified. Choose one of: --format, --seconds, or --json"
		exit 22
	}

	# Determine the output format (handle aliases)
	let output_format = if $seconds {
		"seconds"
	} else if $json {
		"json"
	} else {
		$format
	}

	# Validate format
	if $output_format not-in ["table", "json", "seconds"] {
		print $"Error: Invalid format '($output_format)'. Valid formats: table, json, seconds"
		exit 22
	}

	# Default to VSCode if no apps specified
	let target_apps = if ($apps | length) == 0 { ["vscode"] } else { $apps }

	# Resolve all app inputs to bundle IDs
	let resolved_apps = ($target_apps | each { |app| resolve_app $app })

	# Get the current timezone offset in hours
	let tz_offset_hours = (date now | format date "%z" | str substring 0..3 | into int)

	# Get screen time for all requested apps
	let results = ($resolved_apps | each { |app| get_app_screentime $app $tz_offset_hours })

	# Output based on format
	match $output_format {
		"seconds" => {
			# Sum all total_seconds values and output the total
			let total_seconds = ($results | get total_seconds | math sum)
			print $total_seconds
		}
		"json" => {
			# Output as JSON string
			print ($results | to json)
		}
		"table" => {
			# Add total row only if there are multiple apps
			if ($results | length) > 1 {
				let total_row = (create_total_row $results)
				$results | append $total_row
			} else {
				$results
			}
		}
	}
}
